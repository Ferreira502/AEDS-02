
SEPARAÇÃO DE UMA STRING EM DUAS PARTES

----------------------------------

PROBLEMA

Dada uma string contendo duas palavras separadas por espaço, por exemplo:

"tpo ocder"

Deseja-se separar essa string em duas partes:
parte1 = "tpo"
parte2 = "ocder"

A seguir são apresentadas diferentes abordagens em Java e em C, com análise de complexidade de tempo e espaço.

---

PARTE 1 – LINGUAGEM JAVA

1. Utilizando split()

Descrição:

O método split() divide a string com base em uma expressão regular e retorna um array de Strings.

Exemplo lógico:
String[] partes = str.split(" ");

Complexidade de Tempo:

O(n)

Onde n é o tamanho da string.

Justificativa:
O método precisa percorrer toda a string para localizar os delimitadores (espaços) e construir as substrings.

Complexidade de Espaço:

O(n)

Justificativa:
É criado um novo array de Strings e novas Strings são alocadas na memória.

Observações:

* Utiliza regex internamente.
* Pode ser mais custoso que outras soluções se a expressão regular for complexa.
* É a solução mais simples e legível.

---

2. Utilizando Scanner + split()

Descrição:

O Scanner é usado apenas para entrada de dados.
A separação continua sendo feita com split().

Complexidade de Tempo:

Leitura (nextLine): O(n)
Split: O(n)

Total: O(n)

Complexidade de Espaço:

O(n)

Justificativa:
Mesma justificativa do split(), pois o Scanner apenas lê a entrada.

Observações:

* Boa prática para entrada interativa.
* Complexidade dominada pelo split().

---

3. Utilizando indexOf() + substring()

Descrição:

* indexOf(" ") encontra a posição do primeiro espaço.
* substring() cria duas novas strings.

Complexidade de Tempo:

indexOf(): O(n)
substring(): O(n)

Total: O(n)

Justificativa:
indexOf percorre a string até encontrar o espaço.
substring cria novas cópias dos caracteres.

Complexidade de Espaço:

O(n)

Justificativa:
São criadas duas novas Strings.

Observações:

* Mais eficiente que split() quando só precisamos de duas partes.
* Não utiliza regex.
* Melhor escolha quando sabemos que existe apenas um delimitador.

---

4. Percorrendo caractere por caractere (usando +=)

Descrição:

A string é percorrida manualmente usando charAt() e concatenando caracteres com +=.

Complexidade de Tempo:

O(n²)

Justificativa:
Strings em Java são imutáveis.
Cada operação de += cria uma nova String.
Isso faz com que a cada concatenação seja feita uma cópia da string acumulada.

Exemplo:
Se tivermos n caracteres, o custo será:
1 + 2 + 3 + ... + n
Resultado: O(n²)

Complexidade de Espaço:

O(n²) temporário
O(n) final

Observações:

* Não recomendado para strings grandes.
* Pode causar degradação significativa de desempenho.

---

5. Percorrendo caractere por caractere (usando StringBuilder)

Se substituir += por StringBuilder:

Complexidade de Tempo:

O(n)

Justificativa:
StringBuilder não cria cópias a cada concatenação.

Complexidade de Espaço:

O(n)

Observações:

* Forma manual mais eficiente.
* Boa para controle detalhado da lógica.

---

PARTE 2 – LINGUAGEM C

1. Utilizando sscanf()

Descrição:

sscanf(str, "%s %s", parte1, parte2);

Complexidade de Tempo:

O(n)

Justificativa:
A função percorre a string uma vez para extrair os tokens.

Complexidade de Espaço:

O(1) adicional

Justificativa:
Não há alocação dinâmica (considerando arrays já alocados).
Os dados são copiados para buffers existentes.

Observações:

* Simples e direto.
* Pode gerar problemas se o tamanho do buffer for insuficiente.
* Não faz verificação automática de overflow.

---

2. Percorrendo manualmente (caractere por caractere)

Descrição:

Dois loops percorrem a string até o espaço e depois até o fim.

Complexidade de Tempo:

O(n)

Justificativa:
Cada caractere é visitado no máximo uma vez.

Complexidade de Espaço:

O(1) adicional

Justificativa:
Apenas variáveis de controle e buffers já declarados são usados.

Observações:

* Maior controle.
* Mais seguro quando combinado com validação de limites.
* Muito comum em exercícios acadêmicos.

---

COMPARAÇÃO FINAL

Java split():
Tempo: O(n)
Espaço: O(n)
Mais simples, usa regex.

Java indexOf + substring:
Tempo: O(n)
Espaço: O(n)
Mais eficiente que split para apenas duas partes.

Java manual com +=:
Tempo: O(n²)
Espaço: O(n²) temporário
Não recomendado.

Java manual com StringBuilder:
Tempo: O(n)
Espaço: O(n)
Melhor alternativa manual.

C com sscanf:
Tempo: O(n)
Espaço: O(1)
Simples, mas exige cuidado com buffers.

C manual:
Tempo: O(n)
Espaço: O(1)
Mais controlado e eficiente.

---

CONCLUSÃO

Todas as abordagens eficientes possuem complexidade linear O(n), pois é necessário percorrer a string ao menos uma vez.

A única abordagem com complexidade pior é a concatenação com += em Java, que possui custo quadrático O(n²) devido à imutabilidade das Strings.

Para desempenho e clareza:

* Em Java: indexOf + substring ou StringBuilder são as melhores escolhas.
* Em C: a abordagem manual é simples, eficiente e com menor overhead.

---